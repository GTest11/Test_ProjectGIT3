import clr, sys, os, time, re, timeit, datetime, threading
#''''''''''''''''''''AUTOGENERATED CODE - DO NOT MODIFY''''''''''''''''''''
#clr.AddReference('SkyUtils\SkyUtils')
from System.Collections.Generic import List
#from SkyUtils import ImageUtils, MotionDetector
#import SkyUtils as NowTvHelper

#''''''''''''''''''STB ScriptingLibrary''''''''''''''''''''''''''''''''''''
clr.AddReference("MobileScriptingLibrary")
import MobileScriptingLibrary
dut = MobileScriptingLibrary.MobileDUT()
logger = MobileScriptingLibrary.Logger()
scriptPath = os.path.realpath(__file__)
args = sys.argv
dut.Configure(args[1],args[2],args[3],args[4],scriptPath)
logger.Configure(args[1],args[2],args[3],args[4],scriptPath)

#'''''''''''''''''''''''''END AUTOGENERATED CODE'''''''''''''''''''''''''''

# ********************************Importing required Files*********************
try:
    import shutil,urllib
except ImportError:
    logger.Log("Failed to import python modules")
    logger.Log("Exception raised in importing python modules" +
               str(sys.exc_info()[0])+ str(sys.exc_info()[1]))

# Configuring the path for import
sys.path.append('../')

try:
    import shutil, urllib, xlrd
except ImportError:
    logger.Log("Failed to import python modules")
    logger.Log("Exception raised in importing python modules" +
               str(sys.exc_info()[0])+ str(sys.exc_info()[1]))
try:
    # Import QoE cube Library file
    from Library.FalconEyeCube.Library import CubeAPI as cubeAPI
except ImportError:
    logger.Log("Failed to import Cube library")
    logger.Log("Exception raised in importing Cube library" +
               str(sys.exc_info()[0])+ str(sys.exc_info()[1]))

try:
    from android_core.common import QoEScenario,QoEParams,TestResult,TestVector,Click
    from android_core.msg import Message as msg
except ImportError:
    logger.Log("Failed to import common library")
    logger.Log("Exception raised in importing common library" +
               str(sys.exc_info()[0])+ str(sys.exc_info()[1]))

try:
    from android_core.config import ConfigBase as confFile
except ImportError:
    logger.Log("Failed to import configuration files")
    logger.Log("Exception raised in importing configuration files" +
               str(sys.exc_info()[0])+ str(sys.exc_info()[1]))

# Buffering colours, Tolerance 25 and Min pixel to appear is 80
aBufferIconChecker = None
bufferImgName = ''
PARENT_DIR = os.path.abspath(os.path.join(os.path.dirname(scriptPath), os.pardir))

# *****************************************************************************
def start_up_time(dut, tapelement, timeout=confFile.QoETUNEMAXWAIT_TIME, waitGap=confFile.WAIT_GAP_DETECT_MOTION):
    total_time_taken = 0
    detect_motion_date_time = datetime.datetime.utcnow()
    try:
        # start_time = timeit.default_timer()
        player_loaded = True
        # while (timeit.default_timer() - start_time) <= timeout:
        #     player_loaded = dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.Id,
        #                          confFile.VIDEO_PLAYER)
        #     if player_loaded:
        #         break

        if player_loaded:
            end_time = timeit.default_timer()
            inputParam = MobileScriptingLibrary.HighPrecisionValidationService.MotionParams()
            inputParam.x_cord = 276
            inputParam.y_cord = 400
            inputParam.width = 76
            inputParam.height = 66
            #inputParam.x_cord = 272
            #inputParam.y_cord = 400
            #inputParam.width = 61
            #inputParam.height = 64
            inputParam.sensitivity = 3
            lstInputParam = List[MobileScriptingLibrary.HighPrecisionValidationService.MotionParams]()
            lstInputParam.Add(inputParam)

            inputParam = MobileScriptingLibrary.HighPrecisionValidationService.MotionParams()
            inputParam.x_cord = 52
            inputParam.y_cord = 356
            inputParam.width = 57
            inputParam.height = 191
            #inputParam.x_cord = 41
            #inputParam.y_cord = 350
            #inputParam.width = 60
            #inputParam.height = 282
            inputParam.sensitivity = 45
            lstInputParam.Add(inputParam)

            inputParam = MobileScriptingLibrary.HighPrecisionValidationService.MotionParams()
            inputParam.x_cord = 108
            inputParam.y_cord = 222
            inputParam.width = 249
            inputParam.height = 191
            inputParam.sensitivity = 3
            lstInputParam.Add(inputParam)

            motion_detected_time, detect_motion_duration = get_screen_transitions(dut, lstInputParam, tapelement)

            # detect_motion_duration = dut.validator.DetectMotionEx(confFile.DetectMotion_x, confFile.DetectMotion_y,
            #                                                       confFile.DetectMotion_w, confFile.DetectMotion_h,
            #                                                       timeout, confFile.default_tolerance)
            detect_motion_date_time = motion_detected_time

            if(detect_motion_duration >= 0):
                total_time_taken = (detect_motion_duration/1000.0)

                if VerifyIssueMesssage(dut):
                    total_time_taken = 0
        return total_time_taken, detect_motion_date_time
    except:
        logger.Log("Exception raised in start_up_time" +
                   str(sys.exc_info()[0]) + str(sys.exc_info()[1]) +
                   str(sys.exc_info()[2]))
    return total_time_taken, detect_motion_date_time


# *****************************************************************************
def DetectBuffering(dut):
    bStatus = False
    global buffCheckStartTime
    global wait_time
    try:
        wait_start = timeit.default_timer()
        if not dut.WaitForElement(MobileScriptingLibrary.Constants.ElementType.Id, confFile.BUFFERING_CIRCLE,
                                  confFile.WAITTIME):
            wait_time = wait_start - timeit.default_timer()
            logger.Log("No Buffering")

        else:
            bStatus = True
            buffCheckStartTime = timeit.default_timer()
            logger.Log("Buffering Detected")

    except:
        logger.Log("Exception raised in DetectBuffering" +
                       str(sys.exc_info()[0]))
    return bStatus


def CalculateBufferingTime1(dut, interval, category_type, asset_name, capped_bw, custom_dict=None):
    bBufStatus = False
    actualBufferTime = 0
    bufferTime = 0
    initialBuffDetectTime = 0
    bufferingEndTime = 0
    buffTimeList = []
    totalBufferingTimeForDuration = 0

    istarttime = timeit.default_timer()
    #logger.Log("Start time : " + str(istarttime) )
    isLowBWApplied = False
    isInBufferMode = True

    args['VPF'] = None
    args['dut'] = dut
    t = threading.Thread(target=VerifyIssueMessageInThread, args=(args,))
    t.start()

    while (True):
        try:
            iendtime = timeit.default_timer()

            if (isInBufferMode and not isLowBWApplied and ((iendtime - istarttime) >= 120)):
                isLowBWApplied = True
                cubeAPI.CubeChokeNetwork(limited_bandwidth_down=60)
            if (isInBufferMode and isLowBWApplied and ((iendtime-istarttime) >= 200)):
                cubeAPI.CubeChokeNetwork(limited_bandwidth_down=capped_bw)
                isInBufferMode = False
                isLowBWApplied = False

            if (iendtime-istarttime) > interval:
                if(bBufStatus):
                    bufferingEndTime = timeit.default_timer()
                    logger.Log("Monitoring endtime reached")
                    logger.Log("BUFFERING CONTD TILL MONITORING DURATION")
                    bufferTime = bufferingEndTime - initialBuffDetectTime
                    bufferTime = bufferTime - wait_time  # deducting wait time for detecting no buffering

                    date_time = datetime.datetime.utcnow()
                    buffTimeList.append((date_time, bufferTime))

                    logger.Log("Individual video buffer time (truncated with monitoring duration) " + str(bufferTime))
                interval = iendtime-istarttime # To calculate buffering ratio
                break

            if DetectBuffering(dut):
                if not bBufStatus:
                    initialBuffDetectTime = buffCheckStartTime
                    bBufStatus = True  # Checking whether the video is buffered
                    logger.Log("BUFFERING **START** DETECTED")
                    args['VPF'] = 'Buffering'
            else:
                args['VPF'] = None
                if bBufStatus:

                    bufferingEndTime = timeit.default_timer()

                    logger.Log("BUFFERING **END** DETECTED")

                    bufferTime = bufferingEndTime - initialBuffDetectTime # round(

                    date_time = datetime.datetime.utcnow()
                    buffTimeList.append((date_time, bufferTime))

                    logger.Log("Individual video buffer time " + str(bufferTime))
                    bBufStatus = False
                else:
                    if (args['VPF'] == 'Detected'):
                        date_time = datetime.datetime.utcnow()
                        imageName = "QoE_" + getUniqueFileName(dut) + "_Playback_failure"
                        imagePath = dut.validator.QuickCapture(imageName)
                        logger.Log("Video playback failure detected. Image Name : " + imageName)
                        dut.CommitStepResult("Video Playback Error detected",
                                             TestResult.FAILED)
                        dut.Click(MobileScriptingLibrary.Constants.ElementType.XPath, confFile.OK_BUTTON)
                        qoe_data_push(QoEParams.PLAYBACK_FAILURE, date_time, 1, category_type, asset_name,
                                      capped_bw, custom_dict.copy() )
                        break
        except:
            logger.Log("Exception raised in CalculateBufferingTime" +
                       str(sys.exc_info()[0]))
    try:
        if len(buffTimeList) > 0:
            logger.Log("Identified buffering values in playback " + str(buffTimeList))
            for date_time, duration in buffTimeList:
                qoe_data_push(QoEParams.BUFFERING_TIME, date_time, duration, category_type, asset_name,
                              capped_bw, custom_dict.copy())
                totalBufferingTimeForDuration = totalBufferingTimeForDuration + duration
            logger.Log("Total buffering duration is " + str(totalBufferingTimeForDuration))
            logger.Log("Buffering percentage : " + str((totalBufferingTimeForDuration*100)/interval) + "%")
        else:
            logger.Log("NO BUFFERING DETECTED")

        args['VPF'] = 'Finished'  # To stop the thread
        t.join(30)  # wait till thread terminates
        return totalBufferingTimeForDuration/interval
    except:
        logger.Log("Exception raised in Calculate Buffering time" +
                   str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno)
                   + str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))



def CalculateBufferingTime(dut, interval, category_type, asset_name, capped_bw, custom_dict=None):
    bBufStatus = False
    actualBufferTime = 0
    bufferTime = 0
    initialBuffDetectTime = 0
    bufferingEndTime = 0
    buffTimeList = []
    totalBufferingTimeForDuration = 0

    istarttime = timeit.default_timer()
    #logger.Log("Start time : " + str(istarttime) )

    args['VPF'] = None
    args['dut'] = dut
    t = threading.Thread(target=VerifyIssueMessageInThread, args=(args,))
    t.start()

    while (True):
        try:
            iendtime = timeit.default_timer()
            if (iendtime-istarttime) > interval:
                if(bBufStatus):
                    bufferingEndTime = timeit.default_timer()
                    logger.Log("Monitoring endtime reached")
                    logger.Log("BUFFERING CONTD TILL MONITORING DURATION")
                    bufferTime = bufferingEndTime - initialBuffDetectTime
                    bufferTime = bufferTime - wait_time  # deducting wait time for detecting no buffering

                    date_time = datetime.datetime.utcnow()
                    buffTimeList.append((date_time, bufferTime))

                    logger.Log("Individual video buffer time (truncated with monitoring duration) " + str(bufferTime))
                interval = iendtime-istarttime # To calculate buffering ratio
                break

            if DetectBuffering(dut):
                if not bBufStatus:
                    initialBuffDetectTime = buffCheckStartTime
                    bBufStatus = True  # Checking whether the video is buffered
                    logger.Log("BUFFERING **START** DETECTED")
                    args['VPF'] = 'Buffering'
            else:
                args['VPF'] = None
                if bBufStatus:

                    bufferingEndTime = timeit.default_timer()

                    logger.Log("BUFFERING **END** DETECTED")

                    bufferTime = bufferingEndTime - initialBuffDetectTime # round(

                    date_time = datetime.datetime.utcnow()
                    buffTimeList.append((date_time, bufferTime))

                    logger.Log("Individual video buffer time " + str(bufferTime))
                    bBufStatus = False
                else:
                    if (args['VPF'] == 'Detected'):
                        date_time = datetime.datetime.utcnow()
                        imageName = "QoE_" + getUniqueFileName(dut) + "_Playback_failure"
                        imagePath = dut.validator.QuickCapture(imageName)
                        logger.Log("Video playback failure detected. Image Name : " + imageName)
                        dut.CommitStepResult("Video Playback Error detected",
                                             TestResult.FAILED)
                        dut.Click(MobileScriptingLibrary.Constants.ElementType.XPath, confFile.OK_BUTTON)
                        qoe_data_push(QoEParams.PLAYBACK_FAILURE, date_time, 1, category_type, asset_name,
                                      capped_bw, custom_dict.copy())
                        break
        except:
            logger.Log("Exception raised in CalculateBufferingTime" +
                       str(sys.exc_info()[0]))
    try:
        if len(buffTimeList) > 0:
            logger.Log("Identified buffering values in playback " + str(buffTimeList))
            for date_time, duration in buffTimeList:
                qoe_data_push(QoEParams.BUFFERING_TIME, date_time, duration, category_type, asset_name,
                              capped_bw, custom_dict.copy())

                totalBufferingTimeForDuration = totalBufferingTimeForDuration + duration
            logger.Log("Total buffering duration is " + str(totalBufferingTimeForDuration))
            logger.Log("Buffering percentage : " + str((totalBufferingTimeForDuration*100)/interval) + "%")
        else:
            logger.Log("NO BUFFERING DETECTED")

        args['VPF'] = 'Finished'  # To stop the thread
        t.join(30)  # wait till thread terminates
        return totalBufferingTimeForDuration/interval
    except:
        logger.Log("Exception raised in Calculate Buffering time" +
                   str(sys.exc_info()[0]) + str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno)
                   + str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))


# # *****************************************************************************
# def VerifyIssueMesssage():
#     isErrorScreenDetected = False
#     try:
#         if not dut.validator.DetectMotion(confFile.DETECT_MOTION_CENTER_AREA_X, confFile.DETECT_MOTION_CENTER_AREA_Y, confFile.DETECT_MOTION_CENTER_AREA_W,
#                       confFile.DETECT_MOTION_CENTER_AREA_H, confFile.MAX_ITERATION,confFile.WAIT_GAP,
#                       "2"):
#             isErrorScreenDetected = True
#     except:
#         logger.Log("Exception raised in VerifyIssueMesssage" +
#                    str(sys.exc_info()[0]))
#     return isErrorScreenDetected

args = {'VPF': None}  #video playback failure

# This method to call Verify issue message method in thread
def VerifyIssueMessageInThread(arg):
    logger.Log('Current Status : ' + str(arg['VPF']))
    while arg['VPF'] != 'Finished':
        if arg['VPF'] != 'Buffering':
            if VerifyIssueMesssage(arg['dut']):
                arg['VPF'] = 'Detected'
                break
        time.sleep(20)

# *****************************************************************************
def VerifyIssueMesssage(dut):
    isErrorScreenDetected = False
    try:
        if dut.WaitForElement(MobileScriptingLibrary.Constants.ElementType.XPath, confFile.OK_BUTTON, confFile.WAITTIME):
            isErrorScreenDetected = True
    except:
        logger.Log("Exception raised in VerifyIssueMesssage" +
                   str(sys.exc_info()[0]))
    return isErrorScreenDetected


# *****************************************************************************
def CheckVideoPlaybackFailure(dut, category_type, asset_name, capped_bw, custom_dict=None):
    if not VerifyIssueMesssage(dut):
        logger.Log("No issue message detected after buffering")
        return False
    else:
        date_time = datetime.datetime.utcnow()
        imageName = "QoE_" + getUniqueFileName(dut) + "_Playback_failure"
        imagePath = dut.validator.QuickCapture(imageName)
        logger.Log("Video playback failure detected. Image Name : " + imageName)
        dut.CommitStepResult("Video Playback Error detected",
                             TestResult.FAILED)
        dut.Click(MobileScriptingLibrary.Constants.ElementType.XPath, confFile.OK_BUTTON)
        qoe_data_push(QoEParams.PLAYBACK_FAILURE, date_time, 1, category_type, asset_name,
                      capped_bw, custom_dict.copy())
        return True

# *****************************************************************************
def getNowStr():
    return datetime.datetime.utcnow().strftime("%d%m%Y_%H%M%S")

def getUniqueFileName(dut_object):
    dutName = dut_object.ReadProperty(1)
    dutName = "".join(x for x in dutName if x.isalnum())
    return dutName + "_"+getNowStr()


# def detect_motion(dut,x,y,w,h, total_wait = 2, screen_shot_count=2,
#                   screen_shot_interval=1, precision=90):
#     """
#     Takes screenshots and calls SkyUtils API to detect motion.
#     Returns True or False
#     :param dut: dut object created by MobileScriptingLibrary.MobileDUT()
#     :param rectangle_coords: Coordinates in the screen
#     :param screen_shot_count: Number of screenshots to be taken
#     :param screen_shot_interval: Number of seconds to sleep bw screenshots
#     :param precision: Percentage of precision needed in image comparison
#     """
#
#     last_index = screen_shot_count - 1
#     ss_save_path = os.path.join(confFile.SCREENSHOT_BASE_DIR, confFile.SCREENSHOT_DIRNAME)
#
#     while(total_wait > 0):
#         screenshots = []
#         startTime = timeit.default_timer()
#         if not os.path.exists(ss_save_path):
#             os.makedirs(ss_save_path)
#         for index in range(screen_shot_count):
#             img_str = dut.GetScreenshot()
#             screenshots.append( (img_str, getNowStr()) )
#             if screen_shot_interval and index < last_index:
#                 logger.Log("Sleeping for "+str(screen_shot_interval)+" seconds" )
#                 time.sleep(screen_shot_interval)
#         saved_screenshots = []
#         for ss, ts in screenshots:
#             ss_filename = os.path.join(ss_save_path, ts+".png")
#             ImageUtils.SaveImage(ss, ss_filename)
#             if logger:
#                 logger.Log("Screenshot saved : "+ ss_filename )
#             saved_screenshots.append(ss_filename)
#
#         md = MotionDetector(x,y,w,h, precision)
#         motion_detected = False
#         if md.DetectMotion(saved_screenshots):
#             motion_detected = True
#             break
#
#         endTime = timeit.default_timer()
#
#         total_wait = total_wait - (endTime - startTime)
#
#
#     # Remove screenshots
#     # for ss in saved_screenshots:
#     #     os.remove(ss)
#
#     return motion_detected


# *****************************************************************************
def read_from_scenario_sheet(file_name):
    try:
        logger.Log("entered read_from_scenario_sheet()")
        excel_ext = ".xlsx"
        if excel_ext not in file_name:
            file_name = str(file_name) + str(excel_ext)
        value_list = []
        file_path = os.path.abspath(os.path.join(PARENT_DIR, confFile.TESTSCENARIO_FOLDER+file_name))
        logger.Log("Opening scenario sheet " + file_path)
        wb = xlrd.open_workbook(file_path)
        worksheet = wb.sheet_by_index(0)
        num_cells = worksheet.ncols
        logger.Log("Number of columns present: " + str(num_cells))
        logger.Log("Reading from the sheet.....")
        cells = worksheet.row_slice(rowx=1, start_colx=0, end_colx=num_cells)
        for cell in cells:
            value_list.append(cell.value)
        logger.Log(str(value_list))

        QoEScenario.CATEGORY_NAME = value_list[confFile.SCENARIO_COLUMN["category"]]
        QoEScenario.ASSET_TYPE = value_list[confFile.SCENARIO_COLUMN["asset_type"]]
        QoEScenario.CHANNEL_LIST = value_list[confFile.SCENARIO_COLUMN["channel_list"]]
        QoEScenario.CHANNEL_LIST = QoEScenario.CHANNEL_LIST.split(",")
        QoEScenario.USECASE = int(value_list[confFile.SCENARIO_COLUMN["use_case"]])
        QoEScenario.TEST_VECTOR_NAME = value_list[confFile.SCENARIO_COLUMN["test_vector_file_name"]]
        QoEScenario.TEST_VECTOR_NAME = QoEScenario.TEST_VECTOR_NAME.split(",")
        QoEScenario.CHANNEL_PLAY_TIME = value_list[confFile.SCENARIO_COLUMN["channel_play_time"]] * 60  # converting to seconds
        QoEScenario.LOOP_COUNT = value_list[confFile.SCENARIO_COLUMN["loop_count"]]

    except:
        logger.Log("Exception raised in read_from_scenario_sheet function" + str(sys.exc_info()[0]) +
                   str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno) +
                   str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))

    return QoEScenario


# *****************************************************************************
def read_from_testvector_sheet(qoe_scenario, file_name):
    try:
        excel_ext = ".xlsx"
        if excel_ext not in file_name:
            file_name = str(file_name) + str(excel_ext)
        file_path = os.path.abspath(os.path.join(PARENT_DIR, confFile.TESTVECTOR_FOLDER+file_name))
        logger.Log("Opening test vector sheet " + file_path)
        wb = xlrd.open_workbook(file_path)
        worksheet = wb.sheet_by_index(0)
        test_vectors_list = []
        num_rows = worksheet.nrows
        num_cells = worksheet.ncols
        logger.Log("Number of rows present: " + str(num_rows))
        logger.Log("Number of columns present: " + str(num_cells))

        logger.Log("Reading from the sheet.....")
        for i in range(1, num_rows):
            value_list = []
            cells = worksheet.row_slice(rowx=i, start_colx=0, end_colx=num_cells)
            for cell in cells:
                value_list.append(cell.value)
            logger.Log(str(value_list))
            test_vector = TestVector(i-1)
            test_vector.CHOKE_TIME = value_list[confFile.TESTVECTOR_COLUMN["choke_time"]] * 60  # converting to seconds
            test_vector.LIMITED_BW_UP = value_list[confFile.TESTVECTOR_COLUMN["limited_bw_up"]]
            test_vector.LIMITED_BW_DOWN = value_list[confFile.TESTVECTOR_COLUMN["limited_bw_down"]]
            test_vector.DELAY = value_list[confFile.TESTVECTOR_COLUMN["delay"]]
            test_vector.JITTER = value_list[confFile.TESTVECTOR_COLUMN["jitter"]]
            test_vector.PACKET_LOSS = value_list[confFile.TESTVECTOR_COLUMN["packet_loss"]]
            test_vectors_list.append(test_vector)
        qoe_scenario.TEST_VECTOR_OBJLIST = test_vectors_list

    except:
        logger.Log("Exception raised in read_from_testvector_sheet function" + str(sys.exc_info()[0]) +
                   str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno) +
                   str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))
    return qoe_scenario


# *****************************************************************************
def get_test_args(dut_object):
    try:
        file_name = dut_object.ReadCustomProperty("qoe_scenario_file")
        qoe_scenario = read_from_scenario_sheet(file_name)
        test_vector_file_name = qoe_scenario.TEST_VECTOR_NAME[0]
        logger.Log("Test vector file name(s): " + test_vector_file_name)
        qoe_scenario = read_from_testvector_sheet(qoe_scenario, test_vector_file_name)
        limited_bw_down_list = []
        for obj in qoe_scenario.TEST_VECTOR_OBJLIST:
            limited_bw_down_list.append(obj.LIMITED_BW_DOWN)

        if qoe_scenario.USECASE == 2:
            play_time = 0
            for obj in qoe_scenario.TEST_VECTOR_OBJLIST:
                play_time += obj.CHOKE_TIME
            qoe_scenario.CHANNEL_PLAY_TIME = play_time

        logger.Log("Category: " + qoe_scenario.CATEGORY_NAME)
        logger.Log("Asset Type: " + qoe_scenario.ASSET_TYPE)
        logger.Log("Channel list: " + str(qoe_scenario.CHANNEL_LIST))
        logger.Log("Usecase no: " + str(qoe_scenario.USECASE))
        logger.Log("Channel Play time: " + str(qoe_scenario.CHANNEL_PLAY_TIME))
        logger.Log("Loop count: " + str(qoe_scenario.LOOP_COUNT))
        logger.Log("Limited bandwidth down list: " + str(limited_bw_down_list))

    except:
        logger.Log("Exception raised in get_test_args function" + str(sys.exc_info()[0]) +
                   str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno) +
                   str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))
    return qoe_scenario

# ********************************choke_network********************************
def choke_network(tc_object):
    try:
        #if len(network_list) > index:
        logger.Log("choking network to " + str(tc_object.test_vector_list[tc_object.choke_index].LIMITED_BW_DOWN))
        cubeAPI.CubeChokeNetwork(limited_bandwidth_up=tc_object.test_vector_list[tc_object.choke_index].LIMITED_BW_UP,
                                 limited_bandwidth_down=tc_object.test_vector_list[tc_object.choke_index].LIMITED_BW_DOWN,
                                 delay=tc_object.test_vector_list[tc_object.choke_index].DELAY,
                                 jitter=tc_object.test_vector_list[tc_object.choke_index].JITTER,
                                 packetloss=tc_object.test_vector_list[tc_object.choke_index].PACKET_LOSS)
        tc_object.capped_bw = tc_object.test_vector_list[tc_object.choke_index].LIMITED_BW_DOWN
        time_to_wait = tc_object.test_vector_list[tc_object.choke_index].CHOKE_TIME
        tc_object.choke_index += 1
        if tc_object.choke_index == len(tc_object.test_vector_list):
            tc_object.choke_index = 0  # loops through the test vector list
        tc_object.timer = threading.Timer(time_to_wait, choke_network, [tc_object])
        tc_object.timer.start()
    except:
        logger.Log("Exception raised in choke_network" + str(sys.exc_info()[0]) +
                   str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno) +
                   str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))
# *****************************************************************************
# Method to push data to QoE database using thread
# Author: Faisal

def qoe_data_push(qoe_params, date_time, params_value, category_type, asset_name, capped_bw,
                  custom_attributs_dict=None):
    args = {0: qoe_params, 1: date_time, 2: params_value, 3: category_type, 4: asset_name, 5: capped_bw,
            6: custom_attributs_dict}
    t = threading.Thread(target=qoe_data_push_thread, args=(args,))
    t.start()

#  Thread method to push the data to QoE database
def qoe_data_push_thread(arg):
    push_status = cubeAPI.QoePush(arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6])

    if push_status[QoEParams.STATUS]:
        logger.Log(arg[0] + " pushed to DB successfully")
    else:
        logger.Log(arg[0] + " failed to push to DB")

# ****************************find_qoe_parameters****************************
def find_qoe_parameters(tc_object, checking_time, channel_name, capped_bw, confFile, dut, logger, MobileScriptingLibrary):
    try:

        tuning_time = 0
        tune_failure = 0
        buffering_ratio = 0

        retry = 0
        detect_motion_date_time = datetime.datetime.utcnow()
        while retry <= 2:
            # Calculating startup time
            tuning_time,detect_motion_date_time = start_up_time(dut)
            if tuning_time <= 0:
                if dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.Id,
                                        confFile.ALL_MOVIES_PLAYBUTTON):
                    Click(dut, MobileScriptingLibrary.Constants.ElementType.Id,
                                 confFile.ALL_MOVIES_PLAYBUTTON)
                    retry += 1
                elif dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.Id,
                               confFile.MOVIES_RESUME_BUTTON):
                    Click(dut, MobileScriptingLibrary.Constants.ElementType.Id,
                        confFile.MOVIES_RESUME_BUTTON)
                    retry += 1
                elif dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.XPath,
                                          confFile.FIRST_PLAY_BUTTON):
                        Click(dut, MobileScriptingLibrary.Constants.ElementType.XPath,
                                     confFile.FIRST_PLAY_BUTTON)
                        retry += 1
                else:
                    if dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.XPath,
                                            confFile.X_KIDS_PLAY_BUTTON):
                        kids_vod_selected = True
                        Click(dut, MobileScriptingLibrary.Constants.ElementType.XPath,
                                     confFile.X_KIDS_PLAY_BUTTON)
                        retry += 1
                    else:
                        break
            else:
                break
        if tuning_time > 0:
            tuning_time += checking_time
            date_time = datetime.datetime.utcnow()
            qoe_data_push(QoEParams.START_UP_FAILURE, detect_motion_date_time, tune_failure,
                          tc_object.category_type, tc_object.asset_name, capped_bw, tc_object.custom_dict.copy())
            logger.Log("Startup Failure not detected for {} Channel ".format(tc_object.category_type) + channel_name)
            qoe_data_push(QoEParams.START_UP_TIME, detect_motion_date_time, tuning_time,
                          tc_object.category_type, tc_object.asset_name, capped_bw, tc_object.custom_dict.copy() )
            tc_object.report("[{} channel ".format(tc_object.category_type) + channel_name + "] Startup time : " + str(tuning_time),
                                       TestResult.PASSED, image=False)
            # Calculating buffering time at unrestricted bandwidth
            buffering_ratio = CalculateBufferingTime(dut, tc_object.playback_time,
                                                            tc_object.category_type, tc_object.asset_name,
                                                            capped_bw, tc_object.custom_dict)
            date_time = datetime.datetime.utcnow()
            cubeAPI.CubeDisableNetworkdataPush()
            if buffering_ratio > 0:
                qoe_data_push(QoEParams.BUFFERING_RATIO, date_time, buffering_ratio,
                              tc_object.category_type, tc_object.asset_name, capped_bw, tc_object.custom_dict.copy() )
                tc_object.report(
                    "[{} channel ".format(tc_object.category_type) + channel_name + "] Buffer ratio =" + str(buffering_ratio),
                    TestResult.PASSED, image=False)
            else:
                tc_object.report(
                    "[{} channel ".format(tc_object.category_type) + channel_name + "] Buffer ratio = " + str(buffering_ratio),
                    TestResult.PASSED, image=False)
        else:
            cubeAPI.CubeDisableNetworkdataPush()
            tune_failure = 1
            date_time = datetime.datetime.utcnow()
            qoe_data_push(QoEParams.START_UP_FAILURE, date_time, tune_failure,
                          tc_object.category_type, tc_object.asset_name, capped_bw, tc_object.custom_dict.copy() )
            tc_object.report("[{} channel ".format(tc_object.category_type) + channel_name + "] Startup failure detected",
                                      TestResult.FAILED)
            if dut.IsElementPresent(MobileScriptingLibrary.Constants.ElementType.XPath,
                                    confFile.OK_BUTTON):
                Click(dut, MobileScriptingLibrary.Constants.ElementType.XPath, confFile.OK_BUTTON)

    except:
        logger.Log("Exception raised in find_qoe_parameters function" + str(sys.exc_info()[0]) +
                   str(sys.exc_info()[1]) + str(sys.exc_info()[2].tb_lineno) +
                   str(os.path.split(sys.exc_info()[2].tb_frame.f_code.co_filename)[1]))


'''Method to detect the screen transitions time after a tap
returns detected time and total time takon to detect all screen changes
'''
def get_screen_transitions(dut, motionparams, tapelement, timeout = 30):
    tapDataList = List[MobileScriptingLibrary.Models.TapData]()
    tapData = MobileScriptingLibrary.Models.TapData()
    tapData.type = tapelement[0]
    tapData.value = tapelement[1]
    tapDataList.Add(tapData)

    response = dut.validator.GetScreenTransitions(dut, timeout, motionparams, tapDataList)

    logger.Log(str(response))
    duration = 0.0
    motion_detected_time = datetime.datetime.utcnow()

    if response is not None and response.MotionData is not None:
        for i in response.MotionData:
            duration += float(i.Duration)
            motion_detected_time = i.TimeStamp

    return motion_detected_time, duration

